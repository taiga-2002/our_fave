# distutils: language = c++
# distutils: include_dirs = dwave/gate/simulator/
# cython: language_level=3
# THIS FILE WAS AUTOMATICALLY GENERATED BY dwave/gate/simulator/operation_generation.py

cimport numpy as np
from libc.stdint cimport uint64_t

import numpy as np
import warnings

cdef extern from "./ops.h" nogil:
    void c_single_qubit_little_endian "single_qubit_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_single_qubit_big_endian "single_qubit_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_gate_control_little_endian "apply_gate_control_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0
    )

    void c_apply_gate_control_big_endian "apply_gate_control_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0
    )

    void c_apply_gate_two_control_little_endian "apply_gate_two_control_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0, uint64_t control1
    )

    void c_apply_gate_two_control_big_endian "apply_gate_two_control_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0, uint64_t control1
    )

    void c_apply_swap_little_endian "apply_swap_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1
    )

    void c_apply_swap_big_endian "apply_swap_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1
    )

    void c_apply_cswap_little_endian "apply_cswap_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1, uint64_t control0
    )

    void c_apply_cswap_big_endian "apply_cswap_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1, uint64_t control0
    )

    void c_measurement_computational_basis_op0_apply_big_endian "measurement_computational_basis_op0_apply_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_measurement_computational_basis_op0_norm_big_endian "measurement_computational_basis_op0_norm_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_measurement_computational_basis_op0_apply_little_endian "measurement_computational_basis_op0_apply_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_measurement_computational_basis_op0_norm_little_endian "measurement_computational_basis_op0_norm_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_measurement_computational_basis_op1_apply_big_endian "measurement_computational_basis_op1_apply_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_measurement_computational_basis_op1_norm_big_endian "measurement_computational_basis_op1_norm_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_measurement_computational_basis_op1_apply_little_endian "measurement_computational_basis_op1_apply_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_measurement_computational_basis_op1_norm_little_endian "measurement_computational_basis_op1_norm_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_dephase_noise_op0_apply_big_endian "dephase_noise_op0_apply_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_dephase_noise_op0_norm_big_endian "dephase_noise_op0_norm_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_dephase_noise_op0_apply_little_endian "dephase_noise_op0_apply_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_dephase_noise_op0_norm_little_endian "dephase_noise_op0_norm_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_dephase_noise_op1_apply_big_endian "dephase_noise_op1_apply_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_dephase_noise_op1_norm_big_endian "dephase_noise_op1_norm_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_dephase_noise_op1_apply_little_endian "dephase_noise_op1_apply_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_dephase_noise_op1_norm_little_endian "dephase_noise_op1_norm_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_amplitude_dampening_noise_op0_apply_big_endian "amplitude_dampening_noise_op0_apply_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_amplitude_dampening_noise_op0_norm_big_endian "amplitude_dampening_noise_op0_norm_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_amplitude_dampening_noise_op0_apply_little_endian "amplitude_dampening_noise_op0_apply_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_amplitude_dampening_noise_op0_norm_little_endian "amplitude_dampening_noise_op0_norm_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_amplitude_dampening_noise_op1_apply_big_endian "amplitude_dampening_noise_op1_apply_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_amplitude_dampening_noise_op1_norm_big_endian "amplitude_dampening_noise_op1_norm_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_amplitude_dampening_noise_op1_apply_little_endian "amplitude_dampening_noise_op1_apply_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0,
        np.float64_t amplitude_factor
    )

    np.float64_t c_amplitude_dampening_noise_op1_norm_little_endian "amplitude_dampening_noise_op1_norm_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )


cdef inline single_qubit(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0,
    little_endian=True,
):
    if little_endian:
        return c_single_qubit_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )
    else:
        return c_single_qubit_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )

cdef inline apply_gate_control(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t control0,
    little_endian=True,
):
    if little_endian:
        return c_apply_gate_control_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0
        )
    else:
        return c_apply_gate_control_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0
        )

cdef inline apply_gate_two_control(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t control0, uint64_t control1,
    little_endian=True,
):
    if little_endian:
        return c_apply_gate_two_control_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0, control1
        )
    else:
        return c_apply_gate_two_control_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0, control1
        )

cdef inline apply_swap(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t target1,
    little_endian=True,
):
    if little_endian:
        return c_apply_swap_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1
        )
    else:
        return c_apply_swap_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1
        )

cdef inline apply_cswap(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t target1, uint64_t control0,
    little_endian=True,
):
    if little_endian:
        return c_apply_cswap_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1, control0
        )
    else:
        return c_apply_cswap_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1, control0
        )


cdef inline measurement_computational_basis(
    uint64_t num_qubits,
    complex[::1] state_vector,
    uint64_t target0,
    rng,
    little_endian=True,
    apply_operator=True,
):

    norms = np.empty(2, dtype=np.float64)

    # the accumlative probability
    t = 0.0

    # random variable that will determine which operator is chosen
    u = rng.uniform()

    # the final operator index. if none are chosen due to numerical error, this will
    # be left as -1 and we can handle that case
    op_idx = -1

    # this will be set to the probability of the chosen operator
    p = 0.0

    if little_endian:

        if op_idx < 0:
            op_prob = c_measurement_computational_basis_op0_norm_little_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t > u:
                op_idx = 0
                p = op_prob


        if op_idx < 0:
            op_prob = c_measurement_computational_basis_op1_norm_little_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t <= u:
                warnings.warn(
                    "total probability of operators was less than uniformly random "
                    "variable `u` (likely due to numerical errors), defaulting to final"
                    " operator"
                )
            op_idx = 1
            p = op_prob

    else:

        if op_idx < 0:
            op_prob = c_measurement_computational_basis_op0_norm_big_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t > u:
                op_idx = 0
                p = op_prob


        if op_idx < 0:
            op_prob = c_measurement_computational_basis_op1_norm_big_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t <= u:
                warnings.warn(
                    "total probability of operators was less than uniformly random "
                    "variable `u` (likely due to numerical errors), defaulting to final"
                    " operator"
                )
            op_idx = 1
            p = op_prob


    if p == 0.0:
        raise RuntimeError("cannot normalize state vector, norm too small")

    normalization_factor = 1 / np.sqrt(p)

    if apply_operator:
        if little_endian:

            if op_idx == 0:
                c_measurement_computational_basis_op0_apply_little_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


            elif op_idx == 1:
                c_measurement_computational_basis_op1_apply_little_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )

        else:

            if op_idx == 0:
                c_measurement_computational_basis_op0_apply_big_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


            elif op_idx == 1:
                c_measurement_computational_basis_op1_apply_big_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


    return op_idx



cdef inline dephase_noise(
    uint64_t num_qubits,
    complex[::1] state_vector,
    uint64_t target0,
    rng,
    little_endian=True,
    apply_operator=True,
):

    norms = np.empty(2, dtype=np.float64)

    # the accumlative probability
    t = 0.0

    # random variable that will determine which operator is chosen
    u = rng.uniform()

    # the final operator index. if none are chosen due to numerical error, this will
    # be left as -1 and we can handle that case
    op_idx = -1

    # this will be set to the probability of the chosen operator
    p = 0.0

    if little_endian:

        if op_idx < 0:
            op_prob = c_dephase_noise_op0_norm_little_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t > u:
                op_idx = 0
                p = op_prob


        if op_idx < 0:
            op_prob = c_dephase_noise_op1_norm_little_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t <= u:
                warnings.warn(
                    "total probability of operators was less than uniformly random "
                    "variable `u` (likely due to numerical errors), defaulting to final"
                    " operator"
                )
            op_idx = 1
            p = op_prob

    else:

        if op_idx < 0:
            op_prob = c_dephase_noise_op0_norm_big_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t > u:
                op_idx = 0
                p = op_prob


        if op_idx < 0:
            op_prob = c_dephase_noise_op1_norm_big_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t <= u:
                warnings.warn(
                    "total probability of operators was less than uniformly random "
                    "variable `u` (likely due to numerical errors), defaulting to final"
                    " operator"
                )
            op_idx = 1
            p = op_prob


    if p == 0.0:
        raise RuntimeError("cannot normalize state vector, norm too small")

    normalization_factor = 1 / np.sqrt(p)

    if apply_operator:
        if little_endian:

            if op_idx == 0:
                c_dephase_noise_op0_apply_little_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


            elif op_idx == 1:
                c_dephase_noise_op1_apply_little_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )

        else:

            if op_idx == 0:
                c_dephase_noise_op0_apply_big_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


            elif op_idx == 1:
                c_dephase_noise_op1_apply_big_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


    return op_idx



cdef inline amplitude_dampening_noise(
    uint64_t num_qubits,
    complex[::1] state_vector,
    uint64_t target0,
    rng,
    little_endian=True,
    apply_operator=True,
):

    norms = np.empty(2, dtype=np.float64)

    # the accumlative probability
    t = 0.0

    # random variable that will determine which operator is chosen
    u = rng.uniform()

    # the final operator index. if none are chosen due to numerical error, this will
    # be left as -1 and we can handle that case
    op_idx = -1

    # this will be set to the probability of the chosen operator
    p = 0.0

    if little_endian:

        if op_idx < 0:
            op_prob = c_amplitude_dampening_noise_op0_norm_little_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t > u:
                op_idx = 0
                p = op_prob


        if op_idx < 0:
            op_prob = c_amplitude_dampening_noise_op1_norm_little_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t <= u:
                warnings.warn(
                    "total probability of operators was less than uniformly random "
                    "variable `u` (likely due to numerical errors), defaulting to final"
                    " operator"
                )
            op_idx = 1
            p = op_prob

    else:

        if op_idx < 0:
            op_prob = c_amplitude_dampening_noise_op0_norm_big_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t > u:
                op_idx = 0
                p = op_prob


        if op_idx < 0:
            op_prob = c_amplitude_dampening_noise_op1_norm_big_endian(
                num_qubits,
                <np.complex128_t*>&state_vector[0],
                NULL,
                target0
            )
            t += op_prob
            if t <= u:
                warnings.warn(
                    "total probability of operators was less than uniformly random "
                    "variable `u` (likely due to numerical errors), defaulting to final"
                    " operator"
                )
            op_idx = 1
            p = op_prob


    if p == 0.0:
        raise RuntimeError("cannot normalize state vector, norm too small")

    normalization_factor = 1 / np.sqrt(p)

    if apply_operator:
        if little_endian:

            if op_idx == 0:
                c_amplitude_dampening_noise_op0_apply_little_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


            elif op_idx == 1:
                c_amplitude_dampening_noise_op1_apply_little_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )

        else:

            if op_idx == 0:
                c_amplitude_dampening_noise_op0_apply_big_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


            elif op_idx == 1:
                c_amplitude_dampening_noise_op1_apply_big_endian(
                    num_qubits,
                    <np.complex128_t*>&state_vector[0],
                    NULL,
                    target0,
                    normalization_factor
                )


    return op_idx


