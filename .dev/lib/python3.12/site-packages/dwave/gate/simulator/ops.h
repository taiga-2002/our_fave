// THIS FILE WAS AUTOMATICALLY GENERATED BY dwave/gate/simulator/operation_generation.py
#include <complex.h>
#include <algorithm>


void single_qubit_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (gate_value00 * amp0) + (gate_value01 * amp1);
    std::complex<double> amp_result1 = (gate_value10 * amp0) + (gate_value11 * amp1);
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

void single_qubit_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (gate_value00 * amp0) + (gate_value01 * amp1);
    std::complex<double> amp_result1 = (gate_value10 * amp0) + (gate_value11 * amp1);
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

void apply_gate_control_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t control0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, control0};
  std::sort(positions, positions + 2);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t control_mask = 0 | (1 << control0);
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 2); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (gate_value00 * amp0) + (gate_value01 * amp1);
    std::complex<double> amp_result1 = (gate_value10 * amp0) + (gate_value11 * amp1);
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

void apply_gate_control_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t control0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1), (num_qubits - control0 - 1)};
  std::sort(positions, positions + 2);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t control_mask = 0 | (1 << (num_qubits - control0 - 1));
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 2); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (gate_value00 * amp0) + (gate_value01 * amp1);
    std::complex<double> amp_result1 = (gate_value10 * amp0) + (gate_value11 * amp1);
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

void apply_gate_two_control_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t control0, uint64_t control1)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, control0, control1};
  std::sort(positions, positions + 3);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t mask2 = (1 << positions[2]) - 1;
  uint64_t control_mask = 0 | (1 << control0) | (1 << control1);
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 3); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = ((basis_template & ~mask2) << 1) | (basis_template & mask2);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (gate_value00 * amp0) + (gate_value01 * amp1);
    std::complex<double> amp_result1 = (gate_value10 * amp0) + (gate_value11 * amp1);
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

void apply_gate_two_control_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t control0, uint64_t control1)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1), (num_qubits - control0 - 1), (num_qubits - control1 - 1)};
  std::sort(positions, positions + 3);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t mask2 = (1 << positions[2]) - 1;
  uint64_t control_mask = 0 | (1 << (num_qubits - control0 - 1)) | (1 << (num_qubits - control1 - 1));
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 3); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = ((basis_template & ~mask2) << 1) | (basis_template & mask2);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (gate_value00 * amp0) + (gate_value01 * amp1);
    std::complex<double> amp_result1 = (gate_value10 * amp0) + (gate_value11 * amp1);
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

void apply_swap_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t target1)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, target1};
  std::sort(positions, positions + 2);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask1 = 0 | (1 << target0) | (0 << target1);
  uint64_t target_mask2 = 0 | (0 << target0) | (1 << target1);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 2); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = basis_template | control_mask;
    uint64_t state1 = basis_template | target_mask1;
    uint64_t state2 = basis_template | target_mask2;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp2 = state_vector[state2];
    std::complex<double> amp_result1 = amp2;
    std::complex<double> amp_result2 = amp1;
    state_vector[state1] = amp_result1;
    state_vector[state2] = amp_result2;
  }
}

void apply_swap_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t target1)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1), (num_qubits - target1 - 1)};
  std::sort(positions, positions + 2);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1)) | (0 << (num_qubits - target1 - 1));
  uint64_t target_mask2 = 0 | (0 << (num_qubits - target0 - 1)) | (1 << (num_qubits - target1 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 2); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = basis_template | control_mask;
    uint64_t state1 = basis_template | target_mask1;
    uint64_t state2 = basis_template | target_mask2;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp2 = state_vector[state2];
    std::complex<double> amp_result1 = amp2;
    std::complex<double> amp_result2 = amp1;
    state_vector[state1] = amp_result1;
    state_vector[state2] = amp_result2;
  }
}

void apply_cswap_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t target1, uint64_t control0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, target1, control0};
  std::sort(positions, positions + 3);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t mask2 = (1 << positions[2]) - 1;
  uint64_t control_mask = 0 | (1 << control0);
  uint64_t target_mask1 = 0 | (1 << target0) | (0 << target1);
  uint64_t target_mask2 = 0 | (0 << target0) | (1 << target1);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 3); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = ((basis_template & ~mask2) << 1) | (basis_template & mask2);
    basis_template = basis_template | control_mask;
    uint64_t state1 = basis_template | target_mask1;
    uint64_t state2 = basis_template | target_mask2;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp2 = state_vector[state2];
    std::complex<double> amp_result1 = amp2;
    std::complex<double> amp_result2 = amp1;
    state_vector[state1] = amp_result1;
    state_vector[state2] = amp_result2;
  }
}

void apply_cswap_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, uint64_t target1, uint64_t control0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1), (num_qubits - target1 - 1), (num_qubits - control0 - 1)};
  std::sort(positions, positions + 3);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t mask2 = (1 << positions[2]) - 1;
  uint64_t control_mask = 0 | (1 << (num_qubits - control0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1)) | (0 << (num_qubits - target1 - 1));
  uint64_t target_mask2 = 0 | (0 << (num_qubits - target0 - 1)) | (1 << (num_qubits - target1 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 3); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = ((basis_template & ~mask1) << 1) | (basis_template & mask1);
    basis_template = ((basis_template & ~mask2) << 1) | (basis_template & mask2);
    basis_template = basis_template | control_mask;
    uint64_t state1 = basis_template | target_mask1;
    uint64_t state2 = basis_template | target_mask2;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp2 = state_vector[state2];
    std::complex<double> amp_result1 = amp2;
    std::complex<double> amp_result2 = amp1;
    state_vector[state1] = amp_result1;
    state_vector[state2] = amp_result2;
  }
}

void measurement_computational_basis_op0_apply_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp_result0 = amp0;
    std::complex<double> amp_result1 = 0.0;
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double measurement_computational_basis_op0_norm_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp_result0 = amp0;
    norm += std::norm(amp_result0);
  }
  return norm;
}

void measurement_computational_basis_op0_apply_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp_result0 = amp0;
    std::complex<double> amp_result1 = 0.0;
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double measurement_computational_basis_op0_norm_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp_result0 = amp0;
    norm += std::norm(amp_result0);
  }
  return norm;
}

void measurement_computational_basis_op1_apply_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = 0.0;
    std::complex<double> amp_result1 = amp1;
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double measurement_computational_basis_op1_norm_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result1 = amp1;
    norm += std::norm(amp_result1);
  }
  return norm;
}

void measurement_computational_basis_op1_apply_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = 0.0;
    std::complex<double> amp_result1 = amp1;
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double measurement_computational_basis_op1_norm_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask1 = 0 | (1 << target0);
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result1 = amp1;
    norm += std::norm(amp_result1);
  }
  return norm;
}

void dephase_noise_op0_apply_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.99498743710662 * amp0);
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double dephase_noise_op0_norm_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.99498743710662 * amp0);
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    norm += std::norm(amp_result0);
    norm += std::norm(amp_result1);
  }
  return norm;
}

void dephase_noise_op0_apply_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.99498743710662 * amp0);
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double dephase_noise_op0_norm_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.99498743710662 * amp0);
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    norm += std::norm(amp_result0);
    norm += std::norm(amp_result1);
  }
  return norm;
}

void dephase_noise_op1_apply_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp0);
    std::complex<double> amp_result1 = (-0.1 * amp1);
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double dephase_noise_op1_norm_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp0);
    std::complex<double> amp_result1 = (-0.1 * amp1);
    norm += std::norm(amp_result0);
    norm += std::norm(amp_result1);
  }
  return norm;
}

void dephase_noise_op1_apply_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp0);
    std::complex<double> amp_result1 = (-0.1 * amp1);
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double dephase_noise_op1_norm_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp0);
    std::complex<double> amp_result1 = (-0.1 * amp1);
    norm += std::norm(amp_result0);
    norm += std::norm(amp_result1);
  }
  return norm;
}

void amplitude_dampening_noise_op0_apply_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = amp0;
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double amplitude_dampening_noise_op0_norm_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = amp0;
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    norm += std::norm(amp_result0);
    norm += std::norm(amp_result1);
  }
  return norm;
}

void amplitude_dampening_noise_op0_apply_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = amp0;
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double amplitude_dampening_noise_op0_norm_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = amp0;
    std::complex<double> amp_result1 = (0.99498743710662 * amp1);
    norm += std::norm(amp_result0);
    norm += std::norm(amp_result1);
  }
  return norm;
}

void amplitude_dampening_noise_op1_apply_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp1);
    std::complex<double> amp_result1 = 0.0;
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double amplitude_dampening_noise_op1_norm_big_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {(num_qubits - target0 - 1)};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << (num_qubits - target0 - 1));
  uint64_t target_mask1 = 0 | (1 << (num_qubits - target0 - 1));
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp1);
    norm += std::norm(amp_result0);
  }
  return norm;
}

void amplitude_dampening_noise_op1_apply_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0, double amplitude_factor)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp1);
    std::complex<double> amp_result1 = 0.0;
    amp_result0 = amplitude_factor * amp_result0;
    amp_result1 = amplitude_factor * amp_result1;
    state_vector[state0] = amp_result0;
    state_vector[state1] = amp_result1;
  }
}

double amplitude_dampening_noise_op1_norm_little_endian(uint64_t num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, uint64_t target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  double norm = 0;
  for (uint64_t partial_basis = 0; partial_basis < (num_states >> 1); partial_basis++)
  {
    uint64_t basis_template = partial_basis;
    basis_template = ((basis_template & ~mask0) << 1) | (basis_template & mask0);
    basis_template = basis_template | control_mask;
    uint64_t state0 = basis_template | target_mask0;
    uint64_t state1 = basis_template | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp_result0 = (0.1 * amp1);
    norm += std::norm(amp_result0);
  }
  return norm;
}

