import numpy as np
import matplotlib.pyplot as plt
from openjij import SQASampler
import numpy as np
from pyqubo import Array, Placeholder, Constraint
import openjij as oj
import matplotlib.pyplot as plt
import pandas as pd
import japanize_matplotlib
from dwave.system import DWaveSampler, EmbeddingComposite

genre = 5
choice = 5
num_mem=5
Input = np.zeros((choice, genre), dtype=int)  # choice x genre のゼロ行列を作成

# 各行にランダムに1を配置
for i in range(genre):
    col = np.random.randint(0, choice)  # 0からchoice-1のランダムな列を選択
    Input[col, i] = 1
num_matrices = 10  # 作成する行列の数

# 複数のxi行列を格納するリスト
matrices = []

# 10個のランダム行列を作成
for _ in range(num_matrices):
    matrix = np.zeros((genre, choice), dtype=int)
    # 各行にランダムに1を配置
    for i in range(genre):
        col = np.random.randint(0, choice)  # 0からchoice-1のランダムな列を選択
        matrix[col, i] = 1
    matrices.append(matrix)

# 生成した行列を表示
for idx, matrix in enumerate(matrices):
    print(f"Matrix {idx + 1}:")
    print(matrix)
    print()  # 行列間のスペース

# 類似度行列の初期化
similarity_matrix = np.zeros((num_matrices, num_matrices))

# 類似度を計算 (内積のトレースを使う)
for i in range(num_matrices):
    for j in range(num_matrices):
        # 内積を計算してそのトレースを求める
        similarity_matrix[i, j] = np.trace(np.dot(matrices[i], matrices[j].T))

# 類似度行列を表示
#print("類似度行列:")
# print(similarity_matrix)

# バイナリ変数の定義
x = Array.create('x', shape=(num_mem), vartype='BINARY')
# コスト関数の定義
cost = lambdas[0] * sum(similarity_matrix[i, j] * x[i] * x[j] for i in range(num_mem) for j in range(num_mem))

# パラメータの設定
lambda_values = {
    "lambda1": 1,
    "lambda2": 2,
    "lambda3": 1,
    "lambda4": 5
}

# プレースホルダーの定義 (配列として)
lambdas = [Placeholder(f"lambda{i+1}") for i in range(4)]

constraint=0

for k in range(num_mem):
    for i in range(genre):
        for j range(choice):
            constraint+=lambda[i](Input[i,j]-matrix[k][i,j])